{% extends "../../sample.html" %}
{% block headauthor %}Michael Mahemoff{% endblock %}
{% block pageauthor %}Michael Mahemoff{% endblock %}

{% block headtitle %}"Offline": What does it mean and why should I care?{% endblock %}
{% block pagetitle %}"Offline": What does it mean and why should I care?{% endblock %}
{% block pagebreadcrumb %}"Offline": What does it mean and why should I care?{% endblock %}
{% block date %}August 2, 2010{% endblock %}

{% block browsersupport %}
varies
{% endblock %}

{% block iscompatible %}{% endblock %}

{% block head %}
{% endblock %}

{% block onload %}{% endblock %}

{% block content %}
<h2 id="introduction">Introduction</h2>

<p>"Web" and "online" are two closely associated terms, downright synonymous to many people. So why on earth would we talk about "offline" web technologies, and what does the term even mean?</p>

<p>At one level, we can talk about completely offline web apps, those unusual creatures that run inside a browser, but never see the light of the internet. Typically, they will run on a file:/// URI, pointing to a hard drive, USB key, or DVD (if you remember those). For example, those USB keys you sometimes get at conferences, which you stick in your computer to receive a multimedia presentation of something-or-other, running in your browser. A more complex example is the concept of Single Page Applications, like <a href="http://tiddlywiki.com">TiddlyWiki</a>, a kind of personal notepad that runs entirely offline, exploiting custom browser features to save changes to the hard drive.</p>

<p>However, it gets more nuanced than "always-offline". Another class of applications are "online-offline" apps (sometimes just called "offline apps", somewhat ambiguously). These apps are ultimately intended to sync with the cloud, but can survive periods of downtime. The downtime might be an interim loss of connection, like passing through a tunnel, or an extended period of offline activity, like a long-haul flight. Online-offline applications will handle these cases with varying degrees of gracefulness. An example is <a href="http://gmailblog.blogspot.com/2009/01/new-in-labs-offline-gmail.html">GMail's offline facility</a>.</p>

<p>There are also online-offline applications which intentionally keep certain information locally. Sometimes, that might be done to tie data to the browser, rather than the user's account, e.g. the current song being played by a media player application. Local storage is also an interesting alternative to server-based storage for simple applications without user registration; by offloading data storage to clients, you avoid the hassle of maintaining a database on your server. Of course, you should only do this for non-critical data, e.g. a list of recent searches. Another reason is about security and privacy, the concept of <a href="http://ajaxpatterns.org/Host-Proof_Hosting">Host-Proof Hosting</a>. An early example is <a href="http://www.youngpup.net/2006/10/09/">HalfNote</a>, by Aaron Boodman (now a Chrome engineer).</p>

<p>Online-offline applications comes at the cost of increased complexity, and you ought to consider whether offline support is justified. The argument against this mode is best summed up in <a href="http://37signals.com/svn/posts/347-youre-not-on-a-fucking-plane-and-if-you-are-it-doesnt-matter">a famous article from a few years back</a>. David Hanson makes the argument that it's not worth making offline apps just for airplane activity, which is the one place you're likely to be offline for a long period of time. But there are still situations where it's worthwhile, and also situations where offline technologies are useful for protecting aganst server or network outages Just beware that it comes at the cost of complexity, and that complexity needs to be justified.</p>

<p>Even assuming internet utopia, where everything is always online, offline technologies still server a purpose. Why? Because it's faster that way. Offline technologies support caching and detailed control over caching process. Therefore, web apps can boot quickly and show data instantly. You might protest that these technologies shouldn't be called "offline" if they are used by purely online apps. Well, the term is ambiguous. At one level, "offline technologies" could be defined as "technologies supporting offline apps", making the protest valid. But another definition is "technologies operating outside of the cloud", and that's the one used here. Of course, there's a lot of overlap between the two definitions; offline apps certainly need to operate outside of the cloud.</p>

<p>As well as quick startup, offline can be used in a transient way too. Although bandwidth is much faster these days, there are still noticeable limitations for certain applications, in terms of both throughput and latency. If you were designing a high-density video editor, you'll probably find the video is too big to fit into memory at once, meaning you have to swap content in and out of your app. It would be painfully slow to store the whole thing on a server (unless you and all your users are lucky enough to be on a super-fast network). Much better to store the entire video offline and push changes to the server as and when they happen.</p>

<h2 id="toc-offline-capabilities">Offline Capabilities of HTML5</h2>

<p>There are primarily two offline capabilities: application caching and offline storage. The distinction is core application logic versus data. Application caching involves saving the application's core logic and user-interface. Offline storage is about capturing specific data generated by the user, or resources the user has expressed interest in. Imagine an image editor. Application caching would retain the initial HTML document, the Javascript, the CSS, and any icons and sound samples. Consequently, the next time the user visited the site, it would load immediately. To some extent, regular browser caching will already enable that capability, but browser caches are easily overwritten, whereas application caches are intended to enjoy special status on the user's hard drive, so they can't be displaced just because the user downloaded a large video. In addition, there are APIs to control what's cached and what's not, which is not the same as regular browser caching.

<p>In our image editor example, visiting the site the second time round would load the site instantly, but what if we wanted to show the last image that was edited? This kind of thing is not in the application cache, because it's user-specific. Again, regular browser caching <i>might</i> work, but is not something we can depend on. Instead, we can use offline storage. Whenever the user hits save, we upload to the cloud but we also store the image on disk at the same time, i.e. store it offline. If we want to make an even more robust application, we could keep a loop running to continuously store the image offline. That way, the latest changes are still there if the user lost connectivity and had to shut down the browser before they could get online again.</p>

<p>While there's only one kind of application cache, there's a whole flock of offline storage capabilities available, or becoming available. Let's begin with a quick survey of older storage techniques, those that have been around several years and are not generally associated with the "HTML5" label:</p>

<ul>
<li><strong>Cookies</strong> have been around since the early days of the web. They were originally intended to associate a little data with the user, though these days, most applications only store identifying information, and store the rest of the user's data on the server. Still, the fact that cookies can store some data does put them in the category of offline storage. However, the data capacity is extremely limited, as low as 20 cookies limited to 4KB each according to <a href="http://www.ietf.org/rfc/rfc2109.txt">specification</a>. Just as important, cookies slow down network activity because they are transferred to and from the server inside HTTP headers.</li>
<li><strong>Plugin based storage</strong> has been supported by several plugins, notably Flash, Java, and Google Gears. Since Flash 6, there has been the concept of a local shared object. Java applets have also been an option, since Java can write to local files. Google Gears is a third example of a plugin, and in its case, offline storage was one of the main selling points right from its inception. The main downside of plugin based storage is the obvious one: You have to assume the plugin is present, and with the right version. It's not uncommon for company firewalls to block plugins and for plugin releases to lag behind, or not exist at all, on certain operating systems. You also have to have faith in the plugin manufacturer keeping up plugin quality and market share going forth, versus the easy substitability of open-source, open-standards based, browsers.</li>
<li><strong>Browser-specific features</strong> are features browsers provide outside of standard web technologies. For example, TiddlyWiki and the derivative <a href="http://jquery.tiddlywiki.org/twFile.html">twFile jQuery plugin</a> use IE-specific and Firefox-specific APIs to access the underlying file system on those respective browsers, falling back to Java applets where that's not possible. IE, since version 5, also supports <a href="http://msdn.microsoft.com/en-us/library/ms531424(VS.85).aspx">the UserData API</a>. Similar to plugin based storage, the problem with these is significant: You're requiring the user to be working with a particular browser and you're putting faith in the browser manufacturer going forward. This is different from using features only present in just one or two browsers <i>so far</i>, where the feature is part of an open standards process and other manufacturers are likely to include it in the future.</li>
</ul>

<p>The newer storage APIs, what we might call "HTML5 storage", are generally superior in terms of openness and standards compliance. Of course, not all browsers include all of the new APIs, and you may have to support older browsers that don't include any of them at all. So the older techniques are still useful for graceful degradation.</p>

<p>The newer techniques are Web Storage (also called "Local Storage" or "DOM Storage"), Web SQL Database Storage (or simply "SQL Storage"), IndexedDB, and File Storage. In all cases, the sandboxing principle applies: the store is tied to the domain and cannot be accessed by any other domain. So stores and domains are associated 1:N, where N is the number of distinct storage mechanisms represented by the current browser. For example, Chrome presently supports Web Storage, and Web SQL Database Storage, so a given domain has access to exactly three dedicated stores, one for each type. Let's meet each of the new storage technologies:</p>

<ul>
<li><strong><a href="http://dev.w3.org/html5/webstorage/">Web Storage</a></strong> is a very convenient form of offline storage, being just a simple structure of key-value pairs like any Javascript object. This works well for situations such as the image editor example, where you could store the current image under a "currentImage" key: <code>localStorage["currentImage"] = imageData</code>, and load it back the same way: <code>imageData = localStorage["currentImage"]</code>. There's also a variant: Session Storage. It's there mostly for security purposes, as the data is removed when the window is closed. For many offline storage scenarios, local storage is all you need, and it's the most compatible format right now. The downside is that the data isn't structured, so you can't, for example, pluck out all images of type "JPEG" without iterating through every storage item.</li>

<li><strong><a href="http://dev.w3.org/html5/webdatabase/">Web SQL Database</a></strong> is just like it says on the tin: an offline SQL database. Implementations today are based on SQLLite, a real SQL engine used in real server-side applications, so it's the real deal as far as databases go. It comes with all the pros and cons of traditional databases. On the one hand, you have a fully relational structure, allowing you to rapidly query and manipulate data via joins, e.g. "delete all images whose size is over 1MB and whose creator hasn't logged in for 30 days". You can express that in a line of SQL, whereas you'd have to manually wander through the equivalent corpus of Web Storage data. And even if you had a nice API to do the wandering for you, it would still be considerably slower; SQL benefits from decades of performance tuning. However, it comes at the cost of complexity; Do you really need a full-blown database in your front-end web client? Do you really want to go through the effort of specifying a schema, and coding up SQL for every data access? Sometimes it's overkill. The other issue is compatibility. For now, Microsoft and Mozilla haven't put it in their plans and don't have any (public) plans to do so. You can still use it if you feel there will be advantages, but unless you only need to taarget a particular browser which supports it (e.g. a Chrome extension), don't use it in a way that assumes it's definitely present.</li>

<li><strong><a href="http://www.w3.org/TR/IndexedDB/">IndexedDB</a></strong> is a nice compromise between Web Storage and Web SQL Database. Like the former, it's relatively simple; and like the latter, it's capable of being very fast. The trick is to take a standard mapping, like LocalStorage, but index on certain fields inside the stored data. So if your image data was a structure including a "size" field, you could tell IndexedDB to index on "size". Consequently, you can make fast queries against the "size" field; the implementation won't have to trawl through all the image data structures, because it has a separate list of just the "size" fields. IndexedDB is in a funny state right now; it's not supported on any browser right now, and yet it has all the indications that all the major browsers will support it in the fture. One to watch.</li>

<li><strong><a href="http://www.w3.org/TR/FileAPI/">File</a> <a href="http://www.w3.org/TR/file-writer-api/">Storage</a></strong> fills a niche not supported by the other techniques. You get a way to store binary content (as well as plain-text), and a way to store potentially huge data structures. There are separate <a href="http://www.w3.org/TR/FileAPI/">"FileReader"</a> (what some now mean when they say "File API", because it's in the spec of that name) and <a href="http://www.w3.org/TR/file-writer-api/">FileWriter</a> APIs. File Reader is supported today in Chrome and File Writer should be there soon. A <a href="http://www.w3.org/TR/dap-api-reqs/#file-system">further File System capability</a> may come later, enabling access to an entire directory structure, allowing familiar calls like "create directory" and "delete all files in this directory". Use File storage (if/when it's available) to store large chunks of data, e.g. large text documents or even entire movies.</li>
</ul>

<h2 id="toc-offline-technologies">How to Use the Offline Technologies</h2>

<p>In this section, we'll look at some common problems developers face. The solutions are somewhat speculative, given that most of these technologies are new and in some case, not even implemented yet! Nevertheless, applications like GMail have been using some aspects of these technologies for several years (as well as the earlier Google Gears plugin), and so we can suggest some meaningful rules of thumb.</p>

<h3 id="toc-miscdata">Storing miscellaneous data</h3>

<p>All things being equal, Web Storage should be your default port of call for storing offline data. It's a dead-simple API and one that's widely supported. Only consider using the other techniques if you have a specialised requirement not satisfied by Web Storage.</p>

<h3>Extracting binary resources</h3>

<p>You will sometimes want to extract binary data from a server so it can be retained locally. You can download regular binary files, e.g. an image sitting on a server, with standard XMLHttpRequest calls, but you need to use the right header. As explained on <a href="https://developer.mozilla.org/en/using_xmlhttprequest">MDC</a>, the trick is to override the MIME type:</p>

<pre class="prettyprint">
  req.overrideMimeType('text/plain; charset=x-user-defined');
</pre>

<p>Note this isn't specifically about offline technologies, but it's a common task that will come up when you're using them. The section below explains how you can store binary data, once you've read it.</p>

<h3 id="toc-binary-data">Storing binary data</h3>

<p>You can store binary data directly or you can convert it to plain text. For direct binary storage, you can either use a Web SQL Database with a column of "BLOB" type or File Writer API, once it lands. Alternatively, you can covert the binary content to plain text using a binary encoding technique. The obvious choice is Base 64, since that's the format commonly used on the net and in HTML5, e.g. it's supported by browsers via data: URIs. When you come read back your base64-encoded content, you'll find you can include it in your web app using a data URI, e.g. <code>image.src = "data:image/jpg;base64," + base64data</code>. Unfortunately, base64 encoding can be quite slow, so use the techniques described in the next section to ensure the system stays responsive to user events. Alternatively, it might be worthwhole exposing base64-encoded representations right on your server, so your app can download them and directly store them. It will take up a little more space, to the tune of <a href="http://www.phpied.com/uncompressed-data-in-base64-probably-not/">around 30%</a>, but the UI will run faster.</p>

<h3 id="toc-ui-ticking">Keeping the UI Ticking</h3>

<p>When dealing with large amounts of data, there's a risk your Javascript will get so busy processing data, it won't devote any time to the user interface. Javascript is fundamentally single-threaded, meaning that only one thing happens at a time. If the user clicks a button, for instance, and the system is engaged in a long data activity, the click event will linger on a queue for several seconds and the user will be dismayed. Even longer delays will likely lead to the browser opening a dialog box asking the user if they want to stop the script. Best avoided.</p>

<p>Assuming you can't (or don't want to) reduce the amount of data you're storing, the most important thing you can do is exploit asynchronous APIs. With these APIs, the browser will automatically create a new thread for you, do the work, and then return results back to the main thread. While the other thread is doing the work, your user-interface will keep chugging along nicely in the main thread. If you've made XMLHTTPRequest before, you'll aready know that it's almost always used in asynchronous mode, so you should do that for any Ajax calls. As for storage, most but not all of the APIs have asynchronous modes. LocalStorage is the exception; it's only synchronous, so large quantities of data I/O may slow things down. Web SQL Database, IndexedDB, and File Writer all (will) have both synchronous and asynchronous mode. You should generally favour asynchronous mode, even if it makes the programming model more complex.</p>

<p>The other way to do things asynchronously is to use WebWorkers, a way to introduce new threads into your Javascript, with your own code running in the derivative thread. However, there are some major limitations; the storage APIs generally won't work inside a Worker thread, and messages passed in and out of Workers can take a long time; I've found transferring several MB to and from a worker will take several seconds and lock up the user interface. So only use WebWorkers if you can't achieve the same thing with an aysnchronous storage call. The situation will improve as more browsers support SharedWorkers, which have less limitations (though more complexity for the developer to deal with).</p>

<h3 id="toc-largdata">Storing large amounts of data</h3>

<p>If you are looking to store many Megabytes - or more, beware that there are limits in place, which are handled in different ways depending on the browser and the particular API we're talking about. In most cases, there is a magic number of 5MB. For application cache and the various offline stores, there will be no problem if your domain stores under 5MB. When you go above that, various things can happen: (a) it won't work; (b) the browser will request the user for more space; (c) the browser will check for special configuration (as with the "unlimited_storage" permission in the Chrome extension manifest). In the case of Web SQL Database, for example, Chrome will refuse to store more than 5MB, while Safari will ask the user if they will let the application store more than 5MB. At 10MB, it will ask again.</p>

<h3 id="toc-detect-offline">Detecting if you're online</h3>

<p>There's an HTML5 API to let you query if a browser is online: <code>navigator.online()</code>. It works on recent IE, Firefox, and Opera, but not on Safari and Chrome. At least in the case of Chrome, it's intentionally <i>not</i> supported, for reasons explained <a href="http://code.google.com/p/chromium/issues/detail?id=7469#c7">here</a>:</p>

<blockquote>
<p>navigator.onLine and online/offline events are not supported because they are not useful.  they only tell you about the status of your immediate network adapter.  it doesn't say anything about whether or not you can actually connect to a server.  your ISP connection may be down for example, and your local operating system would have no idea.  your OS would just be able to tell you that "yes, you have a connection to your router." ... the only reliable way to determine if you are online is to actually try to make a connection to a server.  this forces you to write your application in a more robust way.</p>
</blockquote>

<p>The most robust way to detect if you're online is not to detect you're online, but to actually try running operations and be ready to deal with any problems that arise. For instance, if your online-offline app is automatically syncing every 10 seconds, then just keep trying to sync and flag the problem if you're unable to do so after a few attempts.</p>

<h3 id="toc-structure">Structuring file data</h3>

<p>IndexedDB and Web SQL Database support structured data and queries against that structure. So the general guideline would be to use one of those if you're in need of complex queries. But what if you need to store file data? You can use the BLOB type of Web SQL Database, but it's not intended for very large data items and it won't work on all browsers. An alternative is to store the content with File API, while indexing it with IndexedDB or Web SQL Database.</p>

<h3 id="toc-compatibility">Ensuring cross-browser compatibility</h3>

<p>As you've probably noticed by now, storage support varies widely across the different browsers. If that's true for the latest versions of each browser, imagine the differences that arise when you consider older versions too. To handle this, you're best off creating - or reusing - a common storage abstraction, with calls such as <code>store.save(id, data)</code> and <code>store.findByIDs()</code>. An example of an open-source abstraction like this is <a href="http://github.com/jeremydurham/persist-js">persist-js</a>. An abstraction should determine which storage APIs are available (possibly using <a href="http://www.modernizr.com/">the Modernizr API</a>) and then access the store using that API. This will help keep your library portable.</p>

<h3 id="toc-lost-data">Protecting against lost data</h3>

<p>Offline data is best used for caching content, rather than being the primary placeholder for user content. Browsers generally let users delete local storage, and there's a strong risk some users will do so without realising the consequences. Thus, ensure data is frequently sync'd to the server, preferably in an automated fashion.</p>

<h3 id="toc-secure-offline-data">Securing offline data</h3>

<p>As <a href="http://www.nczonline.net/blog/2010/04/13/towards-more-secure-client-side-data-storage/">Nicholas Zakas has pointed out</a>, a critical issue with offline storage is that users often share the same browser. This may not be true with mobile browsers, but it's certainly true in many family homes and scarily more true in the case of internet cafes. There's a big risk of sensitive data being available to other users. They may not even be malicious users; they might just visit the site as someone else, only to find all of the previous user's locally stored data in front of them. A good compromise may be to use the LocalStorage variant, SessionStorage , which deletes data when the window is closed. However, even this is not guaranteed to happen when a user leaves, and it partly defeats the purpose of offline storage anyway. Zakas proposes encrypting any sensitive data before storing it locally, though it remains to be seen if this will be promoted as a best practice, or if it, too, will be seen as not secure enough. For now, use offline storage for caching public data and perhaps other data of a general nature, e.g. an e-book the user has paid to download, but be cautious about permanently storing private data offline.</p>

<h2 id="toc-summary">Summary</h2>

<p>Offline storage has many potential applications, well beyond the obvious "I want my application to run when users are on a plane" scenario. Developers in the past had to resort to workarounds, plugins, or browser-specific APIs, but mdoern developers have a veritable arsenal of standards-based capabilities to leverage. The challenge is to decide which to use when, and to use them in the right way. Hopefully, this article is helpful in guide your decision process.</p>
{% endblock %}
